use std::hash::Hash;
use fsa::{Arc, Automaton};
use log_domain::LogDomain;
use num_traits::One;

/// Language iterator for an `Automaton`.
/// A `BatchGenerator` will extract the n best runs of an `Automaton`
/// and yield a `WordGenerator` that iterates over these n words.
pub struct BatchGenerator<A>
where
    A: Eq + Hash,
{
    // the current FSA
    // after n iterations it is replaced by an FSA not containing the
    // words of all previous iterations
    fsa: Automaton<A>,
    // step size n
    step: usize,
}

impl<A> BatchGenerator<A>
where
    A: Eq + Hash,
{
    /// Initialize a `Generator` object that iterates over all words an `Automaton` recognizes.
    pub fn new(fsa: Automaton<A>, step: usize) -> Self {
        BatchGenerator { fsa, step }
    }
}

/// Iterates over a batch of words generated by an `Automaton`.
pub struct WordGenerator<T> {
    epsilon: bool,
    ends: Vec<usize>,
    start_transitions: Vec<Arc<usize, T>>,
    transition_from: Vec<Option<Arc<usize, T>>>,
}

impl<T: Clone> Iterator for WordGenerator<T> {
    type Item = (Vec<T>, LogDomain<f32>);

    fn next(&mut self) -> Option<(Vec<T>, LogDomain<f32>)> {
        if self.epsilon {
            self.epsilon = false;
            Some((Vec::new(), LogDomain::one()))
        } else if self.start_transitions.is_empty() {
            None
        } else {
            let start_transition = self.start_transitions.remove(0);
            let mut weight = start_transition.weight;
            let mut word: Vec<T> = vec![start_transition.label];
            let mut current_end = start_transition.to;

            while !self.ends.contains(&current_end) {
                if let Some(ref current_transition) = self.transition_from[current_end] {
                    current_end = current_transition.to;
                    word.push(current_transition.label.clone());
                    weight = weight * current_transition.weight;
                } else {
                    panic!("Openfsa (Arc::language): arcs are inconsistent.");
                }
            }

            Some((word, weight))
        }
    }
}

// assume a set of arcs from n-best search, i.e.
// * there are no loops
// * only the first state has multiple outgoing transitions
// computes the set of words
fn language<T>(arcs: Vec<Arc<usize, T>>, start: usize, ends: Vec<usize>) -> WordGenerator<T>
where
    T: Clone,
{
    let mut arc_from = Vec::new();
    let mut starts = Vec::new();
    for arc in arcs {
        let Arc {
            from,
            to,
            label,
            weight,
        } = arc;
        if from == start {
            starts.push(Arc {
                from,
                to,
                label: label.clone(),
                weight,
            });
        } else {
            if arc_from.len() <= from {
                let nones = vec![None; from - arc_from.len() + 1];
                arc_from.extend(nones);
            }
            arc_from[from] = Some(Arc {
                from,
                to,
                label: label.clone(),
                weight,
            });
        }
    }

    WordGenerator {
        epsilon: ends.contains(&start),
        ends,
        start_transitions: starts,
        transition_from: arc_from,
    }
}

impl<A> Iterator for BatchGenerator<A>
where
    A: Eq + Hash + Clone,
{
    type Item = WordGenerator<A>;

    fn next(&mut self) -> Option<WordGenerator<A>> {
        let nbest = self.fsa.n_best_automaton(self.step);
        self.fsa = self.fsa.difference(&nbest);

        {
            let (arcs, start, ends) = nbest.into_arcs();
            if !ends.is_empty() && arcs.iter().any(|arc| arc.from == start) {
                Some(language(arcs, start, ends))
            } else {
                None
            }
        }
    }
}

#[cfg(test)]
mod test {
    use fsa::{Arc, Automaton};
    use log_domain::LogDomain;
    use num_traits::One;
    use super::language;

    #[test]
    fn simple_language() {
        let arcs: Vec<Arc<usize, &str>> = vec![
            Arc {
                from: 1,
                to: 2,
                label: "a",
                weight: LogDomain::new(0.9).unwrap(),
            },
            Arc {
                from: 2,
                to: 3,
                label: "word",
                weight: LogDomain::one(),
            },
        ];
        let words: Vec<(Vec<&str>, LogDomain<f32>)> =
            vec![(vec!["a", "word"], LogDomain::new(0.9).unwrap())];
        let words_: Vec<(Vec<&str>, LogDomain<f32>)> = language(arcs, 1, vec![3]).collect();

        assert_eq!(words, words_);
    }

    #[test]
    fn n_best() {
        let arcs: Vec<Arc<&str, &str>> = vec![
            Arc {
                from: "1",
                to: "2",
                label: "a",
                weight: LogDomain::new(0.9).unwrap(),
            },
            Arc {
                from: "2",
                to: "1",
                label: "word",
                weight: LogDomain::one(),
            },
        ];
        let words: Vec<(Vec<&str>, LogDomain<f32>)> = vec![
            (Vec::new(), LogDomain::one()),
            (vec!["a", "word"], LogDomain::new(0.9).unwrap()),
        ];

        match Automaton::from_arcs("1", vec!["1"], arcs.clone())
            .n_best_automaton(2)
            .into_arcs()
        {
            (arcs, q0, qf) => {
                let words_: Vec<(Vec<&str>, LogDomain<f32>)> = language(arcs, q0, qf).collect();
                assert_eq!(words, words_)
            }
        };
    }
}
